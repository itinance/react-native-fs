#import <React/RCTEventEmitter.h>

#ifdef RCT_NEW_ARCH_ENABLED
#import "RNReactNativeFsSpec.h"

@interface ReactNativeFs : RCTEventEmitter <NativeReactNativeFsSpec>
#else
#import <optional>
#import <React/RCTCxxConvert.h>
#import <React/RCTManagedPointer.h>

// These are automatically generated by RN Codegen when using the New Arch,
// however for the backward compatibility to the Old Arch we need to provide
// these ourselves.
namespace JS {
  namespace NativeReactNativeFs {
    struct FileOptions {
      NSString *NSFileProtectionKey() const {
        return _v[@"NSFileProtectionKey"];
      };
      FileOptions(NSDictionary *const v) : _v(v) {}
    private:
      NSDictionary *_v;
    };

    struct MkdirOptions {
      std::optional<bool> NSURLIsExcludedFromBackupKey() const {
        return _v[@"NSURLIsExcludedFromBackupKey"];
      }
      NSString *NSFileProtectionKey() const {
        return _v[@"NSFileProtectionKey"];
      }

      MkdirOptions(NSDictionary *const v) : _v(v) {}
    private:
      NSDictionary *_v;
    };

    struct NativeDownloadFileOptions {
      double jobId() const { return [_v[@"jobId"] doubleValue]; }
      NSString *fromUrl() const  { return _v[@"fromUrl"]; }
      NSString *toFile() const  { return _v[@"toFile"]; }
      bool background() const  { return _v[@"background"]; }
      double backgroundTimeout() const  { return [_v[@"backgroundTimeout"] doubleValue]; }
      bool cacheable() const  { return _v[@"cacheable"]; }
      double connectionTimeout() const  { return [_v[@"connectionTimeout"] doubleValue]; }
      bool discretionary() const  { return _v[@"discretionary"]; }
      id<NSObject>  headers() const  { return _v[@"headers"]; }
      double progressDivider() const  { return [_v[@"progressDivider"] doubleValue]; }
      double progressInterval() const  { return [_v[@"progressInterval"] doubleValue]; }
      double readTimeout() const  { return [_v[@"readTimeout"] doubleValue]; }
      bool hasBeginCallback() const  { return _v[@"hasBeginCallback"]; }
      bool hasProgressCallback() const  { return _v[@"hasProgressCallback"]; }
      bool hasResumableCallback() const  { return _v[@"hasResumableCallback"]; }

      NativeDownloadFileOptions(NSDictionary *const v) : _v(v) {}
    private:
      NSDictionary *_v;
    };

    typedef NSDictionary NativeUploadFileOptions;
    typedef NSDictionary TouchOptions;

    /*
    struct UploadFileItem {
      NSString *name() const;
      NSString *filename() const;
      NSString *filepath() const;
      NSString *filetype() const;

      UploadFileItem(NSDictionary *const v) : _v(v) {}
    private:
      NSDictionary *_v;
    };

    template <typename T>
    using LazyVector = FB::LazyVector<T,id>;

    struct NativeUploadFileOptions {
      NSString *toUrl() const;
      std::optional<bool> binaryStreamOnly() const;
      LazyVector<UploadFileItem> files() const;
      id<NSObject> _Nullable headers() const;
      id<NSObject> _Nullable fields() const;
      NSString *method() const;

      NativeUploadFileOptions(NSDictionary *const v) : _v(v) {}
    private:
      NSDictionary *_v;
    };

    struct TouchOptions {
      std::optional<double> ctime() const;
      std::optional<double> mtime() const;

      TouchOptions(NSDictionary *const v) : _v(v) {}
    private:
      NSDictionary *_v;
    };
     */
  }
}

@implementation RCTCxxConvert (NativeReactNativeFs_FileOptions)
+ (RCTManagedPointer *)JS_NativeReactNativeFs_FileOptions:(id)json
{
  return facebook::react::managedPointer<JS::NativeReactNativeFs::FileOptions>(json);
}
@end
@implementation RCTCxxConvert (NativeReactNativeFs_MkdirOptions)
+ (RCTManagedPointer *)JS_NativeReactNativeFs_MkdirOptions:(id)json
{
  return facebook::react::managedPointer<JS::NativeReactNativeFs::MkdirOptions>(json);
}
@end

@interface ReactNativeFs : RCTEventEmitter <RCTBridgeModule>
#endif

@property (retain) NSMutableDictionary* downloaders;
@property (retain) NSMutableDictionary* uuids;
@property (retain) NSMutableDictionary* uploaders;

@end
